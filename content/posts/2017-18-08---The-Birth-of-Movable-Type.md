---
title: "実践サーバサイドプログラミング-Day4-"
date: "2020-04-26T22:12:03.284Z"
template: "post"
draft: false
slug: "day4"
category: "Programming"
tags:
  - "AJAX"
  - "WebSocket"
description: "実践サーバサイドプログラミングのDay4ということでAJAXやWebSocketのお勉強をしていきます。"
---

## 今回やっていくこと

こんにちわ、rattsl([@rattsl](https://twitter.com/rattsl))です。

今回はクライアントJavaScriptにおけるAJAX通信とAJAXのデメリットに対する解決策としてのWebSocketの学習をしていきます。

## AJAXとは

AJAXとは、**Asynchronous JavaScript + XML**の略で、非同期でサーバにHTTPリクエストを行い、その結果をUIに反映させたりする技術を指します。データのフォーマットは、基本的に通信量や利用のしやすさからJSON形式でレスポンスが返ってくるようになっています。AJAX通信が有名になったのは、Googleマップが利用されてからで、多くの人に使われるようになりました。画面をピンチアウトしたときに一瞬白くなっているのがリアルタイムで非同期通信されている証拠です。

またAJAX通信を繰り返すことで**SPA(Single Page Applicatiopn)**という技術を実現することができるようになりました。

## SPAとは

SPAとは**単一のWebページで複数の機能を表現したアプリケーション**を指します。従来のボタンをクリックしたらHTTPリクエストが飛び、サーバがそのリクエストに対してHTMLページをレスポンスで返すという通信手法は、その度にページが読み込まれ画面が遷移するという特徴がありました。。それに対しSPAは**単一ページで切り替えを行うため、ページ全体の遷移は必要なく、ブラウザの挙動に縛られないUX**を可能にします。

## AJAXを使ってみる

早速AJAXを利用し自動的にサーバの状態を取得し表示するアプリを作ってみます。アーキテクチャ自体は前回同様テンプレートエンジンをPugにしたExpressでクライアントをJQueryで実装していきます。まず始めにサーバサイドでサーバの状態を返すWebAPIを実装していきます。ここでのサーバの状態とはロードアベレージを表しますが、その前にこのロードアベレージとはなんでしょうか？

### Load Average

ロードアベレージとは**1CPUにおける単位時間あたりの実行待ちとディスクI/O待ちのプロセス数**です。 よくサーバーにおける負荷を計測する値として用いられ、値が大きいほどサーバに負荷がかかっていることを表します。コンソールで`uptime`と入力すると

```
 22:58:12 up 17:56,  1 user,  load average: 0.00, 0.00, 0.00
```

と出力されます。`load average:`のラベルの後は直近1分の値、直近5分の値、直近15分の値が表示されます。

***

今回`routes/server-status`にGETでアクセスしロードアベレージの配列を表示させたいのでファイルを生成して記述していきます。

```

//routes/server-status.js

'use strict';
const express = require('express');
const router = express.Router();
const os = require('os');

router.get('/', (req, res, next) => {
  res.json({ loadavg: os.loadavg() });
});

module.exports = router;
```

Expressモジュールとloadavgを使用するためのosモジュールを読み込み、`/`に対してイベントハンドラを設定しています。`/`にgetでアクセスがあったときにjson形式でロードアベレージをレスポンスします。

次に`app.js`にこのオブジェクトを設定します。

```
var serverStatus = require('./routes/server-status');
app.use('/server-status', serverStatus);
```

これでサーバの状態を取得するWebAPIが完成しました。次にクライアントサイドJavaScriptを実装していきます。`views/index.pug`に表示エリアを書きます。

```
// index.pug

h3 ロードアベレージ
p#loadavg
```

ここでは見出しをロードアベレージとしてidをloadavgとしたpタグを用意しました。この記述に対してAJAX通信を行うクライアントJavaScriptを記述していきます。`app/entry.js`を以下のように実装します。

```
// app/entry.js

const loadavg = $('#loadavg');

setInterval(() => {
  $.get('/server-status', {}, (data) => {
    loadavg.text(data.loadavg.toString());
  });
}, 10);
```

まずloadavgというidが設定された段落要素を表すjQueryオブジェクトを読み込んでいます。

次に`setInterval関数`です。`setInterval()`メソッドは、一定の遅延間隔を置いて関数やコードスニペットを繰り返し呼び出します。ここでは第二引数の10ミリ秒の間隔で、無名関数である第一引数のgetメソッドを呼び出しています。この無名関数には、受け取ったデータが`data`という引数に渡されるので、そのプロパティのloadavgの配列取得して文字列に変換し、段落の内部のテキストとして設定しています。

ここまでできたらJavaScriptをまとめてサーバを起動します。

```
node_modules/.bin/webpack
PORT=8000 yarn start
```

[http://localhost:8000/](http://localhost:8000/) にアクセスします。

```
ロードアベレージ
0.1318359375,0.1982421875,0.17626953125
```

上記のようにロードアベレージが更新されていたら成功です。10ミリ秒に1度、1秒間に100回アクセスするのでサーバに負荷がかかり値がどんどん大きくなりますが、数分後一定の値に落ち着くことがわかります。これが動的にHTMLのコンテンツを描画するAJAX通信です。

このようにサーバに対して一定感覚でリクエストを送り情報を取得するのを**ポーリング**をいいます。現在アクセスしているクライアントは1台なので大丈夫ですが、多くのユーザが1台のサーバに対してリクエストを送ると当然サーバにかかる負荷が大きくなります。なのでポーリングは状況に合わせて実行する必要があります。

またAJAXを利用するときは注意するべき点があり、それは同一生成元ポリシーです。

## 同一生成元ポリシー

同一生成元ポリシー（Same-Origin Policy）とは**サーバにリクエストされたコンテンツが同一の生成元かどうかを確認する、ブラウザのセキュリティの考え方**です。なぜこのポリシーが存在するのでしょうか。例えばですが、見ず知らずの人がクロスドメインで自分が利用している写真を保存しているサーバに勝手にアクセスし、写真を他のサイトで利用したり削除していたらどうでしょう。プライベートがダダ漏れで非常に恐ろしいことがおきます。これを防ぐためにAJAX通信には生成元が異なるリソースにはアクセスできないというポリシーが適応されているのです。

しかし、場合によっては、WebページはそのWebサイトを信頼する複数のオリジンからのアセットにアクセスする必要があることがあります。 この場合に、**CORS**（Cross Origin Resource Sharing）という、異なるオリジンからコンテンツへのアクセスの許可を検証するためにブラウザーによって使用されるメカニズムを利用することも可能です。

オリジンの判断方法ですが、サーバー上においてAJAXリクエストは`X-Requested-With`というヘッダがあるかどうかで判定し、さらにサーバーが持っている同一生成元ポリシーの設定を確認してクロスサイトとみなすかどうか判定し、アクセスを制限します。

HTMLのフォームから行う`POST`のリクエストですが、別サイトから実行される可能性があり、それが CSRF脆弱性の原因となっていました。
そのためフォームから行う`POST`のリクエストではCSRFトークンなどを利用し、別サイトからリクエストが行われることを未然に防いでいました。

## Websocket

ここまではAJAXとセキュリティの話でしたが、ここからはWebsocketに入ります。Websocketとは一体なんでしょうか。

Websocketとは**Webサーバーとブラウザの間で利用できる双方向通信の規格です**

リアルタイム性の観点から話すと、AJAX通信はリアルタイムを実現するために短いスパンで何度もクライアント側からサーバにリクエストを送信し、そしてその度にTCPの接続コストが発生し、同じHTTPのヘッタを何度も送る必要がありました。これはスマートではありません。

そこでこの解決策としてのWebsocketが登場します。WebSocketはHTTPのリクエストがあると接続を維持し、常に双方向の通信が可能な状態を構築します。

より詳しく説明するとAJAX通信は**プル型の通信**であるのに対し、Websocketは**プッシュ型の通信**と言われてます。

プル通信は**クライアント側からサーバに対して情報を要求する構造**であるのに対してプッシュ型は**サーバ側から任意のタイミングでクライアントに情報を送信するという構造**になっています。そのためプル型は二度のやりとりがあるに対し、プッシュ型は一方向の送信であるため、よりリアルタイムなクライアントサーバ通信を**負荷をかけずに**実現することができます。

特徴はおいておき、それではインストールして使っていきます。コードはAJAXで実装した者と同様で、サーバの状態をクライアントに表示します。

## インストール

今回利用するライブラリは**Socket.IO**というNode.jsでWebSocketを使うためのライブラリの一つです。コンソールで次のコマンドを実行します。

```
yarn add socket.io@2.1.1 socket.io-client@2.1.1
```

ふたつインストールしていますが、`socket.io@2.1.1`はサーバサイドで利用するモジュール、`socket.io-client@2.1.1`はクライアントサイドで利用するモジュールです。

次に`bin/www`の一番下に次のコードを書き加えます。このファイルはサーバを立ち上げる際に一番始めに読み込まれるファイルです。

```
var io = require('socket.io')(server);
var os = require('os');

function emitServerStatus(socket) {
  socket.emit('server-status', { loadavg: os.loadavg() });
  console.log('server-status event emitted.');
}

io.on('connection', function (socket) {
  setInterval(emitServerStatus, 10, socket);
});
```

説明していきます。ioという変数ですが通常のrequire文とは違い、ioというコネクションを表すオブジェクトを`http.Server`モジュールから引っ張ってきています。

emitServerStatus関数は`server-status`というイベントをWebSocketに対して発行する関数です。AJAXの時と同様にロードアベレージが`loadavg`というプロパティで配列を持つオブジェクトが渡されるようにデータを受渡しています。socket.emit関数は`server-status`というイベントをデータと共に発行できる関数です。その後コンソールにemitできたことを表す文言を表示させています。

その次の実装はWebSocketの接続ができた後、setInterval関数を10ミリ秒感覚で実行する記述です。

次にクライアントサイドの実装を行ってきます。`entry.js`を次のように書き換えていきます。

```
-setInterval(() => {
-  $.get('/server-status', {}, (data) => {
-    loadavg.text(data.loadavg.toString());
-  });
-}, 10);

+import io from 'socket.io-client';
+const socket = io('http://localhost:8000');
+socket.on('server-status', (data) => {
+  loadavg.text(data.loadavg.toString());
+});
```

`socket.io-cliant`モジュールを読み込み、`http://localhost:8000`に接続するオブジェクトを生成します。その後WebSocketの接続上で、 `server-status`という文字列で定義されるイベントが発生した場合のハンドラを設定し、データを受け取り`jQuery`オブジェクトを利用して段落の中の文字列を描画するコードになります。そしていつも通り、webpackとサーバを起動します。

先ほどのAJAXととWebSocketの実装のロードアベレージの値を比べるとどうでしょうか。今回の値の方が負荷が少なくなっていることが確認できると思います。

## 要件によって使う技術を選定する

ここだけを見るとAJAXよりWebSocketを使うべきだと思うかもしれませんが、両者とも特徴がありメリットデメリットもあります。なので実装するサービスに合わせて使い分けできるようにしっかりその技術の特徴を理解する必要があります。

## まとめ

* AJAXはブラウザ上JavaScriptから非同期通信のリクエストを行い、UIの更新を行う技術。プル型。
* WebSocketはサーバクライアント間での双方向通信を行う規格。プッシュ型。
* 通信方式は要件に合わせて利用する必要がある。





